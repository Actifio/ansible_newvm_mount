---

# Pre-FLight check for variable consistency
- fail:
    msg: the variable "{{ item }}" should be defined.
  when: item == ''
  with_items:
    - "{{ act_appname }}"
    - "{{ act_vendorkey }}"
    - "{{ act_restoretime }}"
    - "{{ vm_mgmtserver }}"
    - "{{ vm_src_esxhost }}"
    - "{{ vm_tgt_esxhost }}"
    - "{{ vm_name }}"
    - "{{ vm_datastore }}"

# Generate a login token using the username, password and vendorkey
- name: generating authentication token 
  uri:
    url: "{{ act_api_login }}"
    validate_certs: no  
  register: logintoken

- name: session id is a fact
  set_fact: 
    act_sessionid: "{{ logintoken.json.sessionid }}"

# Filte out the applicationid based on the application_name and source_esxihost
- name: get the application id
  uri:
    url: "{{ act_api_info }}/lsapplication?sessionid={{ act_sessionid }}&filtervalue={{ 'appname=' | urlencode }}{{ act_appname }}{{ '&auxinfo=' | urlencode }}{{ vm_src_esxhost  }}"
    validate_certs: no
    method: GET
  register: lsapplication   

# Extract the apptype of the application. Using this in mountimage
- name: saving application class
  set_fact: 
    apptype: "{{ lsapplication.json.result[0].apptype }}"

# Pre-flight check for apptype
- fail:
    msg: the variable "{{ item }}" should be defined.
  when: apptype != 'VMBackup'
  
# try to ascertain the destination vCenter/ESXi management host ID
- name: search for host_id from name
  block: 
    - uri:
        url: "{{ act_api_info }}/lshost?sessionid={{ act_sessionid }}&filtervalue={{ 'hostname=' | urlencode }}{{ vm_mgmtserver }}"
        validate_certs: no
      register: mgmthostid
    
    - set_fact:
        mgmt_host_id: "{{ mgmthostid.json.result.0.id }}"
      when: mgmthostid is defined

# try to ascertain the destination ESXi host ID
- name: search for host_id from name
  block: 
    - uri:
        url: "{{ act_api_info }}/lshost?sessionid={{ act_sessionid }}&filtervalue={{ 'hostname=' | urlencode }}{{ vm_tgt_esxhost }}"
        validate_certs: no
      register: esxhostid
    
    - set_fact:
        esx_host_id: "{{ esxhostid.json.result.0.id }}"
      when: esxhostid is defined

# Fail if the host could not be found
- name: fail when the management or target host cannot be found
  fail:
    msg: "Unable to find a hostID with a matching description" 
  when: item == ''
  with_items:
    - "{{ mgmthostid }}"
    - "{{ esxhostid }}"

- block:
# Filter all the available backups if the jobclass is not specified
    - block: 
        - name: get the image list select the image from (for all the job_classes)
          uri: 
            url: "{{ act_api_info }}/lsbackup?filtervalue={{ 'appid=' | urlencode }}{{ lsapplication.json.result[0].id }}&sessionid={{ act_sessionid }}"
            validate_certs: no
          register: lsbackup
        - set_fact:
            image_list: "{{ lsbackup }}"
      when: act_job_class == ''

    # Filter all the backup images if the jobclass is specified.
    - block:
        - name: get the image list select the image from (for {{ act_job_class }} job_class)
          uri: 
            url: "{{ act_api_info }}/lsbackup?filtervalue={{ 'appid=' | urlencode }}{{ lsapplication.json.result[0].id }}{{ '&jobclass=' | urlencode }}{{ act_job_class | urlencode }}&sessionid={{ act_sessionid }}"
            validate_certs: no
          register: lsbackup
        - set_fact:
            image_list: "{{ lsbackup }}"
      when: act_job_class != ''

    # Selecting the image to mount based on the restoretime and strict_poliocy
    - name: selecting an image to mount
      uri:
        url: "{{ act_api_info }}/lsbackup?argument={{ item.backupname }}&sessionid={{ act_sessionid }}"
        validate_certs: no
      register: image 
      with_items: 
        - "{{ image_list.json.result }}"

    - name: save the image name to facts
      set_fact: 
        image_name: "{{ image | get_image_name (act_restoretime, strict_policy) }}" # Custom filter plugin
      when: image is defined
  when: act_imagename == ''

- name: non-blocking mount operations
  set_fact: 
    block_mode: "&nowait"
  when: act_nowait_mount == true

- name: blocking mount operations
  set_fact: 
    block_mode: ""
  when: act_nowait_mount != true

- name: specify Physical RDM option
  set_fact: 
    physicalrdm: "&physicalrdm"
  when: vm_physicalrdm == "true"

- name: Not specify Physical RDM option
  set_fact: 
    physicalrdm: ""
  when: vm_physicalrdm != "true"

# Trigger appawre mount
- name: New VM mount 
  uri:
    url: "{{ act_api_task}}/mountimage?image={{ image_name }}&mgmtserver={{ mgmt_host_id }}&esxhost={{ esx_host_id }}&vmname={{ vm_name }}&datastore={{ vm_datastore }}{{ physicalrdm }}&label={{ act_imagelabel }}{{ block_mode }}&sessionid={{ act_sessionid }}&restoreoption={{ 'restoremacaddr=' | urlencode }}{{ vm_restoremac }}{{ ',mapdiskstoallesxhosts=' | urlencode}}{{ vm_mapdiskstoallesx }}"
    method: POST
    validate_certs: no
    timeout: 1200
  async: 0
  when: apptype == "VMBackup" 
